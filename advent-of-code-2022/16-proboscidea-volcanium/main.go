package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strconv"
)

const (
	SRC = "AA"
)

func copyMap[K struct{}](old map[string]K) map[string]K {
	new := make(map[string]K, len(old))

	for key, val := range old {
		new[key] = val
	}

	return new
}

func processLine(line string, valvesMap *map[string][]string, valvesFlowNonZero *map[string]int) {

	rv := regexp.MustCompile("[A-Z][A-Z]")
	inputValves := rv.FindAllString(line, -1)

	rf := regexp.MustCompile("[0-9]+")
	flowRate := rf.FindString(line)

	flow, _ := strconv.Atoi(flowRate)

	(*valvesMap)[inputValves[0]] = inputValves[1:]

	// We don't really care about valves that release no pressure.
	if flow != 0 {
		(*valvesFlowNonZero)[inputValves[0]] = flow
	}
}

// countPressure counts the total pressure emitted by the opened valves.
func countPressure(opened *map[string]struct{}, valvesFlow *map[string]int) int {
	pressure := 0
	for valve := range *opened {
		pressure += (*valvesFlow)[valve]
	}
	return pressure
}

// shortestDistance takes as source a valve and find the shortest distance
// to all valves that emit zero pressure.
func shortestDistance(src string, valvesFlowNonZero map[string]int, valvesMap map[string][]string, distances *map[[2]string]int) {

	if src != SRC {
		// We don't care
		if _, ok := valvesFlowNonZero[src]; !ok {
			return
		}
	}

	(*distances)[[2]string{src, src}] = 0

	visited := make(map[string]struct{}, 0)
	q := make([]string, 0)

	q = append(q, src)
	visited[src] = struct{}{}

	distance := 0
	batchSize := 1

	for len(q) != 0 {
		currentBatch := q[:batchSize]
		q = q[batchSize:]
		distance += 1
		batchSize = 0
		for _, current := range currentBatch {
			for _, next := range valvesMap[current] {

				// If the vertex was not visited, mark it as visited.
				if _, ok := visited[next]; !ok {
					visited[next] = struct{}{}
					q = append(q, next)
					batchSize++

					// Only add it to the distances if it's relevant.
					if _, relevant := valvesFlowNonZero[next]; relevant {
						(*distances)[[2]string{src, next}] = distance
					}
				}
			}
		}
	}

}

func generateSolutions(distances map[[2]string]int, valvesFlowNonZero map[string]int, time int) int {
	// Making a step requires moving to the next valve AND opening it. Just
	// going on to the next valve doesn't to anything.
	//
	// The move can have distance 0 to cover for the first valve, if that one
	// can be opened.
	//
	// Each step will also compute the current score generated by all valves until last step.

	openedValves := make(map[string]struct{}, 0)
	max := 0

	currentValve := "AA"

	initialState := State{
		step:         0,
		total:        0,
		valve:        currentValve,
		openedValves: openedValves,
	}

	q := []State{initialState}

	bfs(q, &max, distances, valvesFlowNonZero, time)

	return max
}

type State struct {
	step         int
	valve        string
	total        int
	openedValves map[string]struct{}
}

func bfs(q []State, max *int, distances map[[2]string]int, valvesFlowNonZero map[string]int, time int) {

	for len(q) > 0 {

		// Remove the current state
		currState := q[0]
		q = q[1:]

		// Loop through all relevant valves
		for next := range valvesFlowNonZero {

			// If we already opened a valve, ignore it.
			if _, ok := currState.openedValves[next]; !ok {

				// distance to the next valve
				distance := distances[[2]string{currState.valve, next}]

				// I will never have time to open the valve and
				// benefit from the fact that it is opened.
				if currState.step+distance >= time-1 {
					if currState.total > *max {
						*max = currState.total
					}
				} else {

					// At the next step, the valve is considered opened and we add to
					// the totalFlow the total pressure generated until step 30.
					adds := (time - (currState.step + distance + 1)) * valvesFlowNonZero[next]

					// Open the valve
					openedValvesCopy := copyMap(currState.openedValves)
					openedValvesCopy[next] = struct{}{}

					nextState := State{
						step:         currState.step + distance + 1,
						valve:        next,
						total:        currState.total + adds,
						openedValves: openedValvesCopy,
					}

					// If opening the valve means that all valves were opened,
					// there is no need to add it to the queue, just check here.
					if len(nextState.openedValves) == len(valvesFlowNonZero) {
						if nextState.total > *max {
							*max = nextState.total
						}
					} else {
						// There are more valves to open
						q = append(q, nextState)
					}
				}

			}
		}

	}

}

func atPos[T int | string](s T, slice []T) int {
	for idx, el := range slice {
		if s == el {
			return idx
		}
	}
	return -1
}

func toMap(elements []string, valvesFlowNonZero map[string]int) map[string]int {
	m := make(map[string]int, 0)

	for _, el := range elements {
		m[el] = valvesFlowNonZero[el]
	}
	return m
}

func setDifference[T int | string](subset []T, all []T) []T {

	difference := []T{}

	for _, el := range all {
		if atPos(el, subset) == -1 {
			difference = append(difference, el)
		}
	}

	return difference
}

// getSubsetIndices generates all subsets of indices from a set with a given
// size of elements
func getSubsetIndices(size int) [][]int {
	subsets := make([][]int, 0)
	q := make([][]int, 0)

	// Add all subsets of one element to q
	for el := 0; el < size; el++ {
		q = append(q, []int{el})
	}

	for len(q) >= 0 {

		first := q[0]

		// We want one of the subsets to always have a smaller size.
		if len(first) > size/2 {
			break
		}

		q = q[1:]
		subsets = append(subsets, first)

		for i := first[len(first)-1] + 1; i < size; i++ {
			firstCopy := make([]int, len(first))
			copy(firstCopy, first)

			firstCopy = append(firstCopy, i)
			q = append(q, firstCopy)
		}

	}

	return subsets

}

func main() {
	f, err := os.Open("input.txt")
	if err != nil {
		panic(err)
	}

	valvesMap := make(map[string][]string)
	valvesFlowNonZero := make(map[string]int)
	distances := make(map[[2]string]int)

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		processLine(line, &valvesMap, &valvesFlowNonZero)
	}

	// Compute the shortest distances between relevant valves.
	for v := range valvesFlowNonZero {
		shortestDistance(v, valvesFlowNonZero, valvesMap, &distances)
	}

	// We need the distances from source as well.
	shortestDistance(SRC, valvesFlowNonZero, valvesMap, &distances)

	part := 2

	if part == 1 {
		max := generateSolutions(distances, valvesFlowNonZero, 30)
		fmt.Println(max)
	} else if part == 2 {

		valvesArray := []string{}
		for valve := range valvesFlowNonZero {
			valvesArray = append(valvesArray, valve)
		}

		valvesSplit := [][2][]string{}
		for _, subset := range getSubsetIndices(len(valvesFlowNonZero)) {

			person := []string{}

			for _, vpos := range subset {
				person = append(person, valvesArray[vpos])
			}
			elephant := setDifference(person, valvesArray)
			valvesSplit = append(valvesSplit, [2][]string{
				person, elephant,
			})

		}

		max := 0

		maxes := make(chan int, 1)

		for idx, splitting := range valvesSplit {

			fmt.Println(idx)

			// Significant improvement brought by multithreading, from 5 mins to
			// about 10 seconds.
			go func(splitting [2][]string) {
				personTime := generateSolutions(distances, toMap(splitting[0], valvesFlowNonZero), 26)
				elephantTime := generateSolutions(distances, toMap(splitting[1], valvesFlowNonZero), 26)

				maxes <- elephantTime + personTime
			}(splitting)

		}

		for i := 0; i < len(valvesSplit); i++ {
			maxTime := <-maxes
			if maxTime > max {
				max = maxTime
			}
		}

		fmt.Println(max)
	}

}
